#!/usr/bin/perl
# #####################################################################
# $Header: LR_4Kst_Result.pl 24-feb-2010 sduprat_es Exp $
#
# LR_4Kst_Result.pl
#
# Copyright (c) 2010, Oracle Consulting (Spain).  All rights reserved.
#
#    NAME
#     LR_4Kst_Result.pl
#
#    DESCRIPTION
#     This perl script is a subroutine: launched by LR_4Kst.pl as part of Residuals Analisis.
#                                       It can't be launched manually, as Param 2 (Pearson's coef) is calculated by LR_4Kst.pl
#
#    NOTES
#           Parameters: 
#               Param 1 = LR_4Kst-<Project>-<metric>.stats file, generated by LR_4Kst.pl
#               Param 2 = Pearson's coeficient, calculated by LR_4Kst.pl
#               Param 3 = Metric Label (Example: "Logical Reads")
#               Param 4 = CPU upper limit for non linearity relationship
#               Param 5 = Average value for metric
#               Param 6 = Max value for metric
#               Param 7 = Standard deviation value for metric
#
#     VERSION      MODIFIED        (MM/DD/YY)
#                  sduprat_es      24/02/10   - Creation and mastermind
#       1.2.6      sduprat_es      15/03/10   - Added parameter 7: metric standard deviation
#
#
# #####################################################################
use Switch;
my $LRResFile;
my $LRStatsFile;
my $cpulimit;
my $AvgX;
my $MaxX;
my $StdevX; ## Metric standard deviation !!!
my $r;
my $m;
my $b;
my $Errm; ## Standard error during the computation of "m" !!!
my $Errb; ## Standard error during the computation of "b" !!!
my $num;

###########
## MAIN ###
###########
$numArgs = $#ARGV + 1;
if ($numArgs > 7 )	{ print "ERROR: to many arguments\nUSAGE: LR_4Kst_Residuals.pl {LR stats file} {Pearson's coef} {metric label} {CPU limit} {Metric AVG} {Metric MAX}\n"; exit -1; }
if ($numArgs < 7 )	{ print "ERROR: to few arguments\nUSAGE: LR_4Kst_Residuals.pl {LR stats file} {Pearson's coef} {metric label} {CPU limit} {Metric AVG} {Metric MAX}\n"; exit -1; }
if ($numArgs == 7 )	{ $LRStatsFile="$ARGV[0]"; $r=$ARGV[1]; $MetricLabel="$ARGV[2]"; $cpulimit=$ARGV[3]; $AvgX=$ARGV[4]; $MaxX=$ARGV[5]; $StdevX=$ARGV[6]}

$LRResFile = $LRStatsFile;
$LRResFile =~ s/\.stats/\.res/;

##
## Primero leemos el fichero de stats (LR_4Kst-<project>-<metric>.stats), para capturar el valor de m,b
## m y b son los coeficientes de Regresion linear calculados por LR_4Kst.pl (f(x) = m*x + b) !!!
##
open ( LR_STATS_FILE, "< $LRStatsFile" ) or die "Can't open $LRStatsFile : $!";
@arr1 = ();
@arr2 = ();
while (<LR_STATS_FILE>)
{
    $line = $_;
    if ($line =~ /^m[ ]*=/)
    {
        chomp($line);
        @arr1 = split(/\s+/, $line);
    }

    if ($line =~ /^b[ ]*=/)
    {
        chomp($line);
        @arr2 = split(/\s+/, $line);
    }

} ## Final lectura de LR_STATS_FILE !!!
close LR_STATS_FILE;

## Esto se queda con los ultimos valores de m y b leidos en el fichero LR_4Kst-<project>-<metric>.stats !!!
$m = @arr1[2];
$b = @arr2[2];
$Errm = @arr1[4];
$Errb = @arr2[4];

##
## Aqui empiezan los calculos de Forecast !!!
##
my $metriclimit; ## Valor de la metrica extrapolado a cpulimit !!!
my $metriclimitMin; ## Valor minimo de la metrica extrapolado a cpulimit !!!
my $metriclimitMax; ## Valor maximo de la metrica extrapolado a cpulimit !!!
my $DeltaMetricLimit;
my $DeltaMetricLimitPct;
my $Delta1;
my $Delta2;
my $PctMax; ## Forecast de la metrica sobre valor Max !!!
my $DeltaPctMax; ## Forecast de la metrica sobre valor Max !!!
my $PctMaxMin; ## Forecast de la metrica sobre valor Max !!!
my $PctMaxMax; ## Forecast de la metrica sobre valor Max !!!
my $PctMed; ## Forecast de la metrica sobre valor Med !!!
my $DeltaPctMed; ## Forecast de la metrica sobre valor Med !!!
my $PctMedMin; ## Forecast de la metrica sobre valor Med !!!
my $PctMedMax; ## Forecast de la metrica sobre valor Med !!!
my $Pct1Sdev; ## Forecast de la metrica sobre valor Med+(1*Stdev) !!!
my $DeltaPct1Sdev; ## Forecast de la metrica sobre valor Med+(1*Stdev) !!!
my $Pct1SdevMin; ## Forecast de la metrica sobre valor Med+(1*Stdev) !!!
my $Pct1SdevMax; ## Forecast de la metrica sobre valor Med+(1*Stdev) !!!
my $Pct2Sdev; ## Forecast de la metrica sobre valor Med+(2*Stdev) !!!
my $DeltaPct2Sdev; ## Forecast de la metrica sobre valor Med+(2*Stdev) !!!
my $Pct2SdevMin; ## Forecast de la metrica sobre valor Med+(2*Stdev) !!!
my $Pct2SdevMax; ## Forecast de la metrica sobre valor Med+(2*Stdev) !!!

$metriclimit = int (( $cpulimit - $b ) / $m) ;
$metriclimitMax = int (( $cpulimit - ($b-$Errb) ) / ($m-$Errm)) ;
$metriclimitMin = int (( $cpulimit - ($b+$Errb) ) / ($m+$Errm)) ;
$Delta1 = $metriclimitMax - $metriclimit;
$Delta2 = $metriclimit - $metriclimitMin;

if ($Delta1>$Delta2)
{
    $DeltaMetricLimit = $Delta1;
}
else
{
    $DeltaMetricLimit = $Delta2;
}
$DeltaMetricLimitPct = ( $DeltaMetricLimit / $metriclimit ) * 100;
##
$PctMax = (( $metriclimit - $MaxX ) / $MaxX) * 100;
$PctMaxMin = (( $metriclimitMin - $MaxX ) / $MaxX) * 100;
$PctMaxMax = (( $metriclimitMax - $MaxX ) / $MaxX) * 100;
##
$PctMed = (( $metriclimit - $AvgX ) / $AvgX) * 100;
$PctMedMin = (( $metriclimitMin - $AvgX ) / $AvgX) * 100;
$PctMedMax = (( $metriclimitMax - $AvgX ) / $AvgX) * 100;
##
$num= $AvgX + (1*$StdevX);
$Pct1Sdev = (( $metriclimit - $num ) / $num) * 100;
$Pct1SdevMin = (( $metriclimitMin - $num ) / $num) * 100;
$Pct1SdevMax = (( $metriclimitMax - $num ) / $num) * 100;
##
$num = $AvgX + (1.96*$StdevX);
$Pct2Sdev = (( $metriclimit - $num ) / $num) * 100;
$Pct2SdevMin = (( $metriclimitMin - $num ) / $num) * 100;
$Pct2SdevMax = (( $metriclimitMax - $num ) / $num) * 100;
##
$Delta1 = $PctMaxMax - $PctMax;
$Delta2 = $PctMax - $PctMaxMin;
if ($Delta1>$Delta2)
{
    $DeltaPctMax = $Delta1;
}
else
{
    $DeltaPctMax = $Delta2;
}
##
$Delta1 = $PctMedMax - $PctMed;
$Delta2 = $PctMed - $PctMedMin;
if ($Delta1>$Delta2)
{
    $DeltaPctMed = $Delta1;
}
else
{
    $DeltaPctMed = $Delta2;
}
##
$Delta1 = $Pct1SdevMax - $Pct1Sdev;
$Delta2 = $Pct1Sdev - $Pct1SdevMin;
if ($Delta1>$Delta2)
{
    $DeltaPct1Sdev = $Delta1;
}
else
{
    $DeltaPct1Sdev = $Delta2;
}
##
$Delta1 = $Pct2SdevMax - $Pct2Sdev;
$Delta2 = $Pct2Sdev - $Pct2SdevMin;
if ($Delta1>$Delta2)
{
    $DeltaPct2Sdev = $Delta1;
}
else
{
    $DeltaPct2Sdev = $Delta2;
}
##


##
## Escritura de los resultados en el fichero de salida !!!
##
open ( LR_RES_FILE, "> $LRResFile") or die "Can't open $LRResFile : $!";
print LR_RES_FILE "Linear Regression Forecast for metric $MetricLabel\n\n";
print LR_RES_FILE "m = $m +/- $Errm\n";
print LR_RES_FILE "b = $b +/- $Errb\n";
print LR_RES_FILE "Pearson's coeficient (r) = $r\n";
print LR_RES_FILE "Metric average value = $AvgX\n";
print LR_RES_FILE "Metric Standard Deviation = $StdevX\n";
print LR_RES_FILE "Metric max value = $MaxX\n";
print LR_RES_FILE "Metric value for non linearity limit ($cpulimit) = $metriclimit +/- $DeltaMetricLimit ($DeltaMetricLimitPct %)\n\n";
## print LR_RES_FILE "Lower Metric value for non linearity limit ($cpulimit) = $metriclimitMin\n";
## print LR_RES_FILE "Upper Metric value for non linearity limit ($cpulimit) = $metriclimitMax\n";
print LR_RES_FILE "Metric MAX forecast:\n";
print LR_RES_FILE "    Upper value (%) = $PctMaxMax\n";
print LR_RES_FILE "    Lower value (%) = $PctMaxMin\n";
print LR_RES_FILE "    Forecast Result (%) = $PctMax +/- $DeltaPctMax\n\n";
print LR_RES_FILE "Metric MED forecast:\n";
print LR_RES_FILE "    Upper value (%) = $PctMedMax\n";
print LR_RES_FILE "    Lower value (%) = $PctMedMin\n";
print LR_RES_FILE "    Forecast Result (%) = $PctMed +/- $DeltaPctMed\n\n";
print LR_RES_FILE "Metric at one STDEV (84% confidence interval) forecast:\n";
print LR_RES_FILE "    Upper value (%) = $Pct1SdevMax\n";
print LR_RES_FILE "    Lower value (%) = $Pct1SdevMin\n";
print LR_RES_FILE "    Forecast Result (%) = $Pct1Sdev +/- $DeltaPct1Sdev\n\n";
print LR_RES_FILE "Metric at two STDEV (95% confidence interval) forecast:\n";
print LR_RES_FILE "    Upper value (%) = $Pct2SdevMax\n";
print LR_RES_FILE "    Lower value (%) = $Pct2SdevMin\n";
print LR_RES_FILE "    Forecast Result (%) = $Pct2Sdev +/- $DeltaPct2Sdev\n";
close (LR_RES_FILE);




